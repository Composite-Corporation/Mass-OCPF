import sqlite3
from dotenv import load_dotenv
from langchain.chains.conversation.base import ConversationChain
from langchain.chains.conversation.memory import ConversationBufferWindowMemory
from langchain_openai import ChatOpenAI
from langchain_core.prompts.prompt import PromptTemplate
from typing import List, Any
from pydantic import BaseModel, Field


class ResponseObject(BaseModel):
    query: str = Field(description="SQL query that was generated")
    results: Any = Field(description="Results from the executed SQL query")
    response: str = Field(description="Response generated by the LLM")


class Text2SQL():

    def __init__(self) -> None:
        # Load environment variables
        load_dotenv()

        # Create conversation chain specialized for generating the SQL queries
        _sql_gen_prompt_template = """
        You are an AI that is given a question from a human and can only strictly return an SQL query for a relational database.
        DO NOT make additional comments or respond in any other way.
        DO NOT use any special formatting and return only raw text.
        
        DATABASE:

        CREATE TABLE dbo_tPUBLICDOCUMENTS_DOCUMENTS (
            Public_Document_ID INTEGER PRIMARY KEY,
            Public_Document_Type_ID INTEGER,
            Public_Document_Code TEXT,
            Title TEXT,
            Description TEXT,
            Body TEXT,
            URL TEXT,
            Is_Public INTEGER,
            Date TEXT, -- Formatted as example: 6/1/2021  12:00:00 AM
            Document_Status_Type_ID INTEGER,
            Subject_Name TEXT,
            Legal_Genesis TEXT,
            Guidance_Issues TEXT,
            Update_Information TEXT,
            Date_Revised TEXT,
            Guidance_Comments TEXT,
            Ordinal INTEGER,
            Doc_Suffix TEXT,
            Year_Section INTEGER
        )

        CREATE TABLE dbo_tPUBLICDOCUMENTS_DOCUMENT_KEYWORDS (
            Public_Document_Keyword_ID INTEGER PRIMARY KEY,
            Public_Document_ID INTEGER,
            Keyword_ID INTEGER,
            Keyword_Weight INTEGER,
            Keyword_Category_ID INTEGER,
            FOREIGN KEY (Public_Document_ID) REFERENCES dbo_tPUBLICDOCUMENTS_DOCUMENTS(Public_Document_ID),
            FOREIGN KEY (Keyword_ID) REFERENCES dbo_tPUBLICDOCUMENTS_KEYWORDS(Keyword_ID)
        )

        CREATE TABLE dbo_tPUBLICDOCUMENTS_KEYWORDS (
            Keyword_ID INTEGER PRIMARY KEY,
            Keyword_Description TEXT,
            Keyword_Category_ID INTEGER
        )

        CURRENT CONVERSATION:
        {history}
        Human: {input}
        AI:"""
        self._sql_gen_conversation = ConversationChain(
            llm=ChatOpenAI(temperature=0, model="gpt-4o"),
            prompt=PromptTemplate(input_variables=["history", "input"], template=_sql_gen_prompt_template),
            memory=ConversationBufferWindowMemory(k=10),
        )

        # Create conversation chain specialized for answering question given SQL results
        _ans_prompt_template = """
        You are an AI that is given a question from a human followed by some information.
        Your task is to answer the question given the additional information.
        If you see any items that contain "None", make sure to include them in the response.

        CURRENT CONVERSATION:
        {history}
        Human: {input}
        AI:"""
        self._ans_gen_conversation = ConversationChain(
            llm=ChatOpenAI(temperature=0, model="gpt-4o"),
            prompt=PromptTemplate(input_variables=["history", "input"], template=_ans_prompt_template),
            memory=ConversationBufferWindowMemory(k=10),
        )


    def _text_to_sql(self, text: str) -> str:
        response = self._sql_gen_conversation.predict(input=text)
        return response
    
    
    def _sql_query(self, query: str) -> List:
        # Establish connection to SQL database
        conn = sqlite3.connect("data/public_documents.db")
        cursor = conn.cursor()

        # Execute sample query
        cursor.execute(query)
        result = cursor.fetchall()

        # Close the connection and return results
        conn.close()
        return result
    

    def _answer_generation(self, text: str, info: Any) -> str:
        input = f"{text}\nAdditional Info: {info}"
        response = self._ans_gen_conversation.predict(input=input)
        return response
    

    def converse(self, user_input: str) -> str:
        query = self._text_to_sql(text=user_input)
        results = self._sql_query(query=query)
        response = self._answer_generation(text=user_input, info=results)
        return ResponseObject(query=query, results=results, response=response)
